Scope
------

dirty checking: watch and digest

$watch: (watchFn, listenerFn, valueEq)
whenever watchFn(scope) return a new value, listenFn((newValue, newValue, scope)) is called. valueEq decides whether _.isEqual or === is used to compare.
returns a function that can be called to destroy the watch.

$eval(expr, locals)
evaluates expr with parameter locals

$apply(expr)
evaluates exp and calls $digest on the roots scope and therefore recursively on the whole scope tree.

$digest
checks the watchers until no one changed

$evalAsync
evaluates an expression in the next digest loop. triggers digest on the root scope. Advantage over timeout is that it does it before it can render stuff or do anything else.

$applyAsync
evaluates in the next digest loop. In contrast to to $evalAsync it does not evaluate in the current digest cycle.

$$postDigest
evaluates functions after the diggest loop

$watchGroup
Takes an array of watchfunctions and a listener and calls the listener with all old and new values if at least one watch is dirty in the digest loop.
Returns a destroy function.


Scope inheritance
-----------------
$new(isolated, parent): returns a new child scope. with prototypal inheritance. If isolated is true, the child scope is isolated. if parent is defined then parent is the parent of the new scope in the scope hirarchy but it still inherits from the scope on which new is called.

diggest on a scope: diggests all kids recursively but not its parents!


WatchCollections $$watchCollection(watchFn, listenerFn)
----------------
shallow comparison of collections and Objects returned by the watch function.
This is between the reference and the equality watch.
Implemented using watches and helper functions.







